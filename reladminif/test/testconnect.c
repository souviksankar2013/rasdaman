/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
#include <sqlhdr.h>
#include <sqliapi.h>
#line 1 "testconnect.ec"
/* testconnect.ec
test connection to Informix database
*/

#include <iostream>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <minmax.h>

/*
 * EXEC SQL INCLUDE SQLCA;
 */
#line 11 "testconnect.ec"

#line 11 "testconnect.ec"
#line 1 "/opt/informix/incl/esql/sqlca.h"
/****************************************************************************
 *
 *                               IBM INC.
 *
 *                           PROPRIETARY DATA
 *
 * Licensed Material - Property Of IBM
 *
 * "Restricted Materails of IBM"
 *
 * IBM Informix Client SDK
 *
 * (c)  Copyright IBM Corporation 2002. All rights reserved.
 *
 *
 *  Title:  sqlca.h
 *  Sccsid: @(#)sqlca.h 9.4 1/18/93  11:09:48
 *  Description:
 *      SQL Control Area
 *
 ***************************************************************************
 */

#ifndef SQLCA_INCL
#define SQLCA_INCL

#include "ifxtypes.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct sqlca_s
{
    int4 sqlcode;
    char sqlerrm[72]; /* error message parameters */
    char sqlerrp[8];
    int4 sqlerrd[6];
    /* 0 - estimated number of rows returned */
    /* 1 - serial value after insert or  ISAM error code */
    /* 2 - number of rows processed */
    /* 3 - estimated cost */
    /* 4 - offset of the error into the SQL statement */
    /* 5 - rowid after insert  */
#ifdef _FGL_
    char sqlawarn[8];
#else
    struct sqlcaw_s
    {
        char sqlwarn0; /* = W if any of sqlwarn[1-7] = W */
        char sqlwarn1; /* = W if any truncation occurred or
                database has transactions or
                    no privileges revoked */
        char sqlwarn2; /* = W if a null value returned or
                ANSI database */
        char sqlwarn3; /* = W if no. in select list != no. in into list or
                turbo backend or no privileges granted */
        char sqlwarn4; /* = W if no where clause on prepared update, delete or
                incompatible float format */
        char sqlwarn5; /* = W if non-ANSI statement */
        char sqlwarn6; /* = W if server is in data replication secondary mode */
        char sqlwarn7; /* = W if database locale is different from proc_locale
            */
    } sqlwarn;
#endif
} ifx_sqlca_t;

/* NOTE: 4gl assumes that the sqlwarn structure can be defined as
 *  sqlawarn -- an 8 character string, because single-char
 *  variables are not recognized in 4gl.
 *
 * If this structure should change, the code generated by 4gl compiler
 *  must also change
 */

#ifdef VMS
noshare
#endif /* VMS */

#define SQLNOTFOUND 100

#ifndef IFX_THREAD
extern struct sqlca_s sqlca;

extern int4 SQLCODE;

extern char SQLSTATE[];
#else /* IFX_THREAD */
extern int4* ifx_sqlcode();
extern struct sqlca_s* ifx_sqlca();
#define SQLCODE (*(ifx_sqlcode()))
#define SQLSTATE ((char *)(ifx_sqlstate()))
#define sqlca (*(ifx_sqlca()))
#endif /* IFX_THREAD */

#ifdef __cplusplus
}
#endif

#endif /* SQLCA_INCL */

#line 101 "/opt/informix/incl/esql/sqlca.h"
/*
 * EXEC SQL define SUCCESS 0;
 */
#line 12 "testconnect.ec"

/*
 * EXEC SQL define WARNING 1;
 */
#line 13 "testconnect.ec"

/*
 * EXEC SQL define NODATA 100;
 */
#line 14 "testconnect.ec"

/*
 * EXEC SQL define RTERROR -1;
 */
#line 15 "testconnect.ec"

#line 16 "testconnect.ec"

/*
 * The sqlstate_err() function checks the SQLSTATE status variable to see
 * if an error or warning has occurred following an SQL statement.
 */
int4 sqlstate_err()
{
    int4 err_code = -1;

    if (SQLSTATE[0] == '0') /* trap '00', '01', '02' */
    {
        switch (SQLSTATE[1])
        {
        case '0': /* success - return 0 */
            err_code = 0;
            break;
        case '1': /* warning - return 1 */
            err_code = 1;
            break;
        case '2': /* end of data - return 100 */
            err_code = 100;
            break;
        default: /* error - return SQLCODE */
            break;
        }
    }
    return (err_code);
}

/*
 * The disp_sqlstate_err() function executes the GET DIAGNOSTICS
 * statement and prints the detail for each exception that is returned.
 */
void disp_sqlstate_err()
{
    mint j;

    /*
     *  EXEC SQL BEGIN DECLARE SECTION;
     */
#line 53 "testconnect.ec"
#line 54 "testconnect.ec"
#line 54 "testconnect.ec"
    mint exception_count;
#line 55 "testconnect.ec"
    char overflow[2];
#line 56 "testconnect.ec"
    mint exception_num = 1;
#line 57 "testconnect.ec"
    char class_id[255];
#line 58 "testconnect.ec"
    char subclass_id[255];
#line 59 "testconnect.ec"
    char message[255];
#line 60 "testconnect.ec"
    mint messlen;
#line 61 "testconnect.ec"
    char sqlstate_code[6];
#line 62 "testconnect.ec"
    mint i;
    /*
     *  EXEC SQL END DECLARE SECTION;
     */
#line 63 "testconnect.ec"


    printf("SQLSTATE: %s\n", SQLSTATE);
    printf("SQLCODE: %d\n", SQLCODE);

    /*
     *  EXEC SQL get diagnostics :exception_count = NUMBER, :overflow = MORE;
     */
#line 68 "testconnect.ec"
    {
#line 68 "testconnect.ec"
        static ifx_hostvar_t _SQhtab[] =
        {
            { 0, 1, 102, sizeof(exception_count), 0, 0, 0, 0 },
            { 0, 2, 100, 2, 0, 0, 0, 0 },
            { 0, 0, 0, 0, 0, 0, 0, 0 }
#line 68 "testconnect.ec"
        };
        _SQhtab[0].hostaddr = (char*)&exception_count;
        _SQhtab[1].hostaddr = (overflow);
#line 68 "testconnect.ec"
        sqli_diag_get(ESQLINTVERSION, _SQhtab, -1);
#line 68 "testconnect.ec"
    }

    printf("EXCEPTIONS:  Number=%d\t", exception_count);
    printf("More? %s\n", overflow);

    for (i = 1; i <= exception_count; i++)
    {
        /*
         *      EXEC SQL get diagnostics  exception :i
         *          :sqlstate_code = RETURNED_SQLSTATE,
         *          :class_id = CLASS_ORIGIN, :subclass_id = SUBCLASS_ORIGIN,
         *          :message = MESSAGE_TEXT, :messlen = MESSAGE_LENGTH;
         */
#line 75 "testconnect.ec"
        {
#line 78 "testconnect.ec"
            static ifx_hostvar_t _SQhtab[] =
            {
                { 0, 3, 100, 6, 0, 0, 0, 0 },
                { 0, 4, 100, 255, 0, 0, 0, 0 },
                { 0, 5, 100, 255, 0, 0, 0, 0 },
                { 0, 6, 100, 255, 0, 0, 0, 0 },
                { 0, 7, 102, sizeof(messlen), 0, 0, 0, 0 },
                { 0, 0, 0, 0, 0, 0, 0, 0 }
#line 78 "testconnect.ec"
            };
            _SQhtab[0].hostaddr = (sqlstate_code);
            _SQhtab[1].hostaddr = (class_id);
            _SQhtab[2].hostaddr = (subclass_id);
            _SQhtab[3].hostaddr = (message);
            _SQhtab[4].hostaddr = (char*)&messlen;
#line 78 "testconnect.ec"
            sqli_diag_get(ESQLINTVERSION, _SQhtab, i);
#line 78 "testconnect.ec"
        }

        printf("EXCEPTION %d: SQLSTATE=%s\n", i, sqlstate_code);
        message[messlen - 1] = '\0';
        printf("MESSAGE TEXT: %s\n", message);
        j = byleng(class_id, stleng(class_id));
        class_id[j] = '\0';
        printf("CLASS ORIGIN: %s\n", class_id);
        j = byleng(subclass_id, stleng(subclass_id));
        subclass_id[j] = '\0';
        printf("SUBCLASS ORIGIN: %s\n", subclass_id);
    }
}

void disp_error(char* stmt)
{
}

void disp_exception(char* stmt, int4 sqlerr_code, mint warn_flg)
{
    switch (sqlerr_code)
    {
    case 0:
    case 100:
        break;
    case 1:
        if (warn_flg)
        {
            printf("Warning encountered in %s\n", stmt);
            disp_sqlstate_err();
        }
        break;
    case -1:
        printf("Error encountered in %s\n", stmt);
        disp_sqlstate_err();
        break;
    default:
        printf("INVALID EXCEPTION STATE for %s\n", stmt);
        break;
    }
}

int
check()
{
    mint warn_flg = 1;
    int4 sqlerr_code = 0;

    sqlerr_code = sqlstate_err();
    disp_exception((char*)"error", sqlerr_code, warn_flg);

    return SQLCODE;
}


int
main(int argc, char** argv)
{
    cout << argv[0] << " Informix database access test" << endl;
    if (argc != 2)
    {
        cout << "Usage: " << argv[0] << " connectstring" << endl;
        return 2;
    }

    /*
     *  EXEC SQL BEGIN DECLARE SECTION;
     */
#line 143 "testconnect.ec"
#line 144 "testconnect.ec"
#line 144 "testconnect.ec"
    char id[256];
    /*
     *  EXEC SQL END DECLARE SECTION;
     */
#line 145 "testconnect.ec"


    strcpy(id, argv[1]);
    cout << "using connect string: " << id << endl;

    /*
     *  EXEC SQL CONNECT TO :id;
     */
#line 150 "testconnect.ec"
    {
#line 150 "testconnect.ec"
        sqli_connect_open(ESQLINTVERSION, 0, id, (char*) 0, (ifx_conn_t*) 0, 0);
#line 150 "testconnect.ec"
    }
    check();

    /*
     *  EXEC SQL DISCONNECT CURRENT;
     */
#line 153 "testconnect.ec"
    {
#line 153 "testconnect.ec"
        sqli_connect_close(3, (char*) 0, 0, 0);
#line 153 "testconnect.ec"
    }
    check();

    cout << argv[0] << ": done." << endl;
    return 0;
}


#line 159 "testconnect.ec"
